# README

This codebase has been generated by [Autostrada](https://autostrada.dev/).

## Getting started

Make sure that you're in the root of the project directory, fetch the dependencies with `go mod tidy`, then run the application using `go run ./cmd/api`:

```
$ go mod tidy
$ go run ./cmd/api
```

If you make a request to the `GET /status` endpoint using `curl` you should get a response like this:

```
$ curl -i localhost:4444/status
HTTP/1.1 200 OK
Content-Type: application/json
Date: Mon, 09 May 2022 20:46:37 GMT
Content-Length: 23

{
    "Status": "OK",
}
```

## Project structure

Everything in the codebase is designed to be editable. Feel free to change and adapt it to meet your needs.

|                           |                                                                                                                                                                                        |
|---------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **`cmd/api`**             | Your application-specific code (handlers, routing, middleware, helpers) for dealing with HTTP requests and responses.                                                                  |
| `↳ cmd/api/errors.go`     | Contains helpers for managing and responding to error conditions.                                                                                                                      |
| `↳ cmd/api/handlers.go`   | Contains your application HTTP handlers.                                                                                                                                               |
| `↳ cmd/api/main.go`       | The entry point for the application. Responsible for parsing configuration settings initializing dependencies and running the server. Start here when you're looking through the code. |
| `↳ cmd/api/middleware.go` | Contains your application middleware.                                                                                                                                                  |
| `↳ cmd/api/routes.go`     | Contains your application route mappings.                                                                                                                                              |
| `↳ cmd/api/server.go`     | Contains a helper functions for starting and gracefully shutting down the server.                                                                                                      |

|                          |                                                                                          |
|--------------------------|------------------------------------------------------------------------------------------|
| **`internal`**           | Contains various helper packages used by the application.                                |
| `↳ internal/cookies`     | Contains helper functions for reading/writing signed and encrypted cookies.              |
| `↳ internal/env`         | Contains helper functions for reading configuration settings from environment variables. |
| `↳ internal/funcs/`      | Contains custom template functions.                                                      |
| `↳ internal/leveledlog/` | Contains a leveled logger implementation.                                                |
| `↳ internal/request/`    | Contains helper functions for decoding JSON requests.                                    |
| `↳ internal/response/`   | Contains helper functions for sending JSON responses.                                    |
| `↳ internal/smtp/`       | Contains a SMTP sender implementation.                                                   |
| `↳ internal/validator/`  | Contains validation helpers.                                                             |
| `↳ internal/version/`    | Contains the application version number definition.                                      |

## Configuration settings

Configuration settings are managed via environment variables, with the environment variables read into your application in the `run()` function in the `main.go` file.

You can try this out by setting a `HTTP_PORT` environment variable to configure the network port that the server is listening on:

```
$ export HTTP_PORT="9999"
$ go run ./cmd/api
level="INFO" time="2023-01-28T09:14:11Z" message="starting server on :9999"
```

Feel free to adapt the `run()` function to parse additional environment variables and store their values in the `config` struct. The application uses helper functions in the `internal/env` package to parse environment variable values or return a default value if no matching environment variable is set. It includes `env.GetString()`, `env.GetInt()` and `env.GetBool()` functions for reading string, integer and bool values from environment variables. Again, you can add any additional helper functions that you need.

## Creating new handlers

Handlers are defined as `http.HandlerFunc` methods on the `application` struct. They take the pattern:

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Your handler logic...
}
```

Handlers are defined in the `cmd/api/handlers.go` file. For small applications, it's fine for all handlers to live in this file. For larger applications (10+ handlers) you may wish to break them out into separate files.

## Handler dependencies

Any dependencies that your handlers have should be initialized in the `run()` function `cmd/api/main.go` and added to the `application` struct. All of your handlers, helpers and middleware that are defined as methods on `application` will then have access to them.

You can see an example of this in the `cmd/api/main.go` file where we initialize a new `logger` instance and add it to the `application` struct.

## Creating new routes

[chi](https://github.com/go-chi/chi) version 5 is used for routing. Routes are defined in the `routes()` method in the `cmd/api/routes.go` file. For example:

```
func (app *application) routes() http.Handler {
    mux := chi.NewRouter()

    mux.Get("/your/path", app.yourHandler)

    return mux
}
```

For more information about chi and example usage, please see the [official documentation](https://github.com/go-chi/chi).

## Adding middleware

Middleware is defined as methods on the `application` struct in the `cmd/api/middleware.go` file. Feel free to add your own. They take the pattern:

```
func (app *application) yourMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Your middleware logic...
        next.ServeHTTP(w, r)
    })
}
```

You can then register this middleware with the router using the `Use()` method:

```
func (app *application) routes() http.Handler {
    mux := chi.NewRouter()
    mux.Use(app.yourMiddleware)

    mux.Get("/your/path", app.yourHandler)

    return mux
}
```

It's possible to use middleware on specific routes only by creating route 'groups':

```
func (app *application) routes() http.Handler {
    mux := chi.NewRouter()
    mux.Use(app.yourMiddleware)

    mux.Get("/your/path", app.yourHandler)

    mux.Group(func(mux chi.Router) {
        mux.Use(app.yourOtherMiddleware)

        mux.Get("/your/other/path", app.yourOtherHandler)
    })

    return mux
}
```

Note: Route 'groups' can also be nested.

## Sending JSON responses

JSON responses and a specific HTTP status code can be sent using the `response.JSON()` function. The `data` parameter can be any JSON-marshalable type.

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    err := response.JSON(w, http.StatusOK, data)
    if err != nil {
        app.serverError(w, r, err)
    }
}
```

Specific HTTP headers can optionally be sent with the response too:

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    headers := make(http.Header)
    headers.Set("X-Server", "Go")

    err := response.JSONWithHeaders(w, http.StatusOK, data, headers)
    if err != nil {
        app.serverError(w, r, err)
    }
}
```

## Parsing JSON requests

HTTP requests containing a JSON body can be decoded using the `request.DecodeJSON()` function. For example, to decode JSON into an `input` struct:

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name string `json:"Name"`
        Age  int    `json:"Age"`
    }

    err := request.DecodeJSON(w, r, &input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }

    ...
}
```

Note: The target decode destination passed to `request.DecodeJSON()` (which in the example above is `&input`) must be a non-nil pointer.

The `request.DecodeJSON()` function returns friendly, well-formed, error messages that are suitable to be sent directly to the client using the `app.badRequest()` helper.

## Validating JSON requests

The `internal/validator` package includes a simple (but powerful) `validator.Validator` type that you can use to carry out validation checks.

Extending the example above:

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name      string              `json:"Name"`
        Age       int                 `json:"Age"`
        Validator validator.Validator `json:"-"`
    }

    err := request.DecodeJSON(w, r, &input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }

    input.Validator.CheckField(input.Name != "", "Name", "Name is required")
    input.Validator.CheckField(input.Age != 0, "Age", "Age is required")
    input.Validator.CheckField(input.Age >= 21, "Age", "Age must be 21 or over")

    if input.Validator.HasErrors() {
        app.failedValidation(w, r, input.Validator)
        return
    }

    ...
}
```

The `app.failedValidation()` helper will send a `422` status code along with any validation error messages. For the example above, the JSON response will look like this:

```
{
    "FieldErrors": {
        "Age": "Age must be 21 or over",
        "Name": "Name is required"
    }
}
```

In the example above we use the `CheckField()` method to carry out validation checks for specific fields. You can also use the `Check()` method to carry out a validation check that is _not related to a specific field_. For example:

```
input.Validator.Check(input.Password == input.ConfirmPassword, "Passwords do not match")
```

The `validator.AddError()` and `validator.AddFieldError()` methods also let you add validation errors directly:

```
input.Validator.AddFieldError("Email", "This email address is already taken")
input.Validator.AddError("Passwords do not match")
```

The `internal/validator/helpers.go` file also contains some helper functions to simplify validations that are not simple comparison operations.

|                                            |                                                                          |
|--------------------------------------------|--------------------------------------------------------------------------|
| `NotBlank(value string)`                   | Check that the value contains at least one non-whitespace character.     |
| `MinRunes(value string, n int)`            | Check that the value contains at least n runes.                          |
| `MaxRunes(value string, n int)`            | Check that the value contains no more than n runes.                      |
| `Between(value, min, max T)`               | Check that the value is between the min and max values inclusive.        |
| `Matches(value string, rx *regexp.Regexp)` | Check that the value matches a specific regular expression.              |
| `In(value T, safelist ...T)`               | Check that a value is in a 'safelist' of specific values.                |
| `AllIn(values []T, safelist ...T)`         | Check that all values in a slice are in a 'safelist' of specific values. |
| `NotIn(value T, blocklist ...T)`           | Check that the value is not in a 'blocklist' of specific values.         |
| `NoDuplicates(values []T)`                 | Check that a slice does not contain any duplicate (repeated) values.     |
| `IsEmail(value string)`                    | Check that the value has the formatting of a valid email address.        |
| `IsURL(value string)`                      | Check that the value has the formatting of a valid URL.                  |

For example, to use the `Between` check your code would look similar to this:

```
input.Validator.CheckField(validator.Between(input.Age, 18, 30), "Age", "Age must between 18 and 30")
```

Feel free to add your own helper functions to the `internal/validator/helpers.go` file as necessary for your application.

## Logging

The `internal/leveledlog` package provides a leveled-logger implementation. It outputs color-coded log lines in the following format:

```
level="INFO" time="2022-08-15T08:51:09+02:00" message="starting server on localhost:4444 (version 0.0.1)"
```

By default, a logger is initialized in the `main()` function which writes all log messages to `os.Stdout`. You can call the logger's `Info()`, `Warn()`, `Error()` and `Fatal()` methods to log messages at different levels with `fmt.Printf` style formatting. For example:

```
logger.Info("starting server on %d", 1234)
```

Note: Calling `Fatal()` will cause your application to terminate.

Also note: Any messages that are automatically logged by the Go `http.Server` are output at `Warning()` level.

If you want to disable the color-coding, then pass `false` as the final parameter when initializing the logger in `main()`.

```
logger := leveledlog.NewLogger(os.Stdout, leveledlog.LevelAll, false)
```

You can also write JSON-formatted log entries instead by using the `NewJSONLogger()` function to initialize the logger:

```
logger := leveledlog.NewJSONLogger(os.Stdout, leveledlog.LevelAll)
```

JSON-formatted log entries are not color-coded.

Feel free to adapt the `internal/leveledlog` package to change this behavior or include additional fields if you want.

## Cookies

The `internal/cookies` package provides helper functions for reading and writing cookies.

The `Write()` function base64-encodes the cookie value and checks the cookie length is no more than 4096 bytes before writing the cookie. You can use it like this:

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Initialize a Go cookie as normal.
    cookie := http.Cookie{
        Name:     "exampleCookie",
        Value:    "Hello Zoë!",
        Path:     "/",
        MaxAge:   3600,
        HttpOnly: true,
        Secure:   true,
        SameSite: http.SameSiteLaxMode,
    }

    // Write the cookie.
    err := cookies.Write(w, cookie)
    if err != nil {
        app.serverError(w, r, err)
        return
    }

    ...
}
```

The `Read()` function reads a named cookie and base64-decodes the value before returning it.

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Read the cookie value and handle any errors as necessary for your application.
    value, err := cookies.Read(r, "exampleCookie")
    if err != nil {
        switch {
        case errors.Is(err, http.ErrNoCookie):
            app.badRequest(w, r, err)
        case errors.Is(err, cookies.ErrInvalidValue):
            app.badRequest(w, r, err)
        default:
            app.serverError(w, r, err)
        }
        return
    }

    ...
}
```

The `internal/cookies` package also provides `WriteSigned()` and `ReadSigned()` functions for writing/reading signed cookies, and `WriteEncrypted()` and `ReadEncrypted()` functions encrypted cookies. Signed cookies are authenticated using HMAC-256, meaning that you can trust that the contents of the cookie has not been tampered with. Encrypted cookies are encrypted using AES-GCM, which both authenticates and encrypts the cookie data, meaning that you can trust that the contents of the cookie has not been tampered with _and_ the contents of the cookie cannot be read by the client.

When using these helper functions, you must set your own (secret) key for signing and encryption. This key should be a random 32-character string generated using a CSRNG which you pass to the application using the `COOKIE_SECRET_KEY` environment variable. For example:

```
$ export COOKIE_SECRET_KEY="heoCDWSgJ430OvzyoLNE9mVV9UJFpOWx"
$ go run ./cmd/api
```

To write a new signed or encrypted cookie:

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Initialize a Go cookie as normal.
    cookie := http.Cookie{
        Name:     "exampleCookie",
        Value:    "Hello Zoë!",
        Path:     "/",
        MaxAge:   3600,
        HttpOnly: true,
        Secure:   true,
        SameSite: http.SameSiteLaxMode,
    }

    // Write a signed cookie using WriteSigned() and passing in the secret key
    // as the final argument. Use WriteEncrypted() if you want an encrpyted
    // cookie instead.
    err := cookies.WriteSigned(w, cookie, app.config.cookie.secretKey)
    if err != nil {
        app.serverError(w, r, err)
        return
    }

    ...
}
```

To read a signed or encrypted cookie:

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Read the cookie value using ReadSigned() and passing in the secret key
    // as the final argument. Use ReadEncrypted() if you want to read an
    // encrpyted cookie instead.
    value, err := cookies.ReadSigned(r, "exampleCookie", app.config.cookie.secretKey)
    if err != nil {
        switch {
        case errors.Is(err, http.ErrNoCookie):
            app.badRequest(w, r, err)
        case errors.Is(err, cookies.ErrInvalidValue):
            app.badRequest(w, r, err)
        default:
            app.serverError(w, r, err)
        }
        return
    }

    ...
}
```

## Sending emails

The application is configured to support sending of emails via SMTP.

Email templates should be defined as files in the `assets/emails` folder. Each file should contain named templates for the email subject, plaintext body and — optionally — HTML body.

```
{{define "subject"}}Example subject{{end}}

{{define "plainBody"}}
This is an example body
{{end}}

{{define "htmlBody"}}
<!doctype html>
<html>
    <head>
        <meta name="viewport" content="width=device-width" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    </head>
    <body>
        <p>This is an example body</p>
    </body>
</html>
{{end}}
```

A further example can be found in the `assets/emails/example.tmpl` file. Note that your email templates automatically have access to the custom template functions defined in the `internal/funcs` package.

Emails can be sent from your handlers using `app.mailer.Send()`. For example, to email `alice@example.com` containing the contents of the `assets/emails/example.tmpl` file:

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    data := map[string]any{"Name": "Alice"}

    err := app.mailer.Send("alice@example.com", data, "example.tmpl")
    if err != nil {
        app.serverError(w, r, err)
        return
    }

   ...
}
```

Note: The second parameter to `Send()` should be a map or struct containing any dynamic data that you want to render in the email template.

The SMTP host, port, username, password and sender details can be configured using the `SMTP_HOST` environment variable, `SMTP_PORT` environment variable, `SMTP_USERNAME` environment variable, `SMTP_PASSWORD` environment variable, and `SMTP_FROM` environment variable or by adapting the default values in `cmd/api/main.go`.

You may wish to use [Mailtrap](https://mailtrap.io/) or a similar tool for development purposes.

## Error notifications

The application supports sending alerts for runtime errors to an admin email address. You can enable this by setting the `NOTIFICATIONS_EMAIL` environment variable to a valid email address.

If you don't set a value for this, then no notifications will be sent (but the errors will still be logged).

Notifications will only be sent for any errors that are encountered as part of a request-response cycle (i.e. whenever a user sees an '500 Internal Server Error' response). Notifications are not sent for any errors that occur when starting or shutting down the application, so it's important to still use an uptime monitoring service in production.

The code for this functionality is in the `sendErrorNotification()` method (in the `cmd/api/errors.go` file) and the email template for the notification is located at `assets/emails/error-notification.tmpl`.

You'll need to make sure that the application is [configured using valid SMTP credentials](#sending-emails) in order to send the email.

## Custom template functions

Custom template functions are defined in `internal/funcs/funcs.go` and are automatically made available to your

email templates when you use `app.mailer.Send()`
.

The following custom template functions are already included by default:

|                              |                                                                                                                                                                    |
|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `now`                        | Returns the current time.                                                                                                                                          |
| `timeSince arg1`             | Returns the time elapsed since arg1.                                                                                                                               |
| `timeUntil arg2`             | Returns the time until arg1.                                                                                                                                       |
| `formatTime arg1 arg2`       | Returns the time arg2 as formatted using the pattern arg1.                                                                                                         |
| `approxDuration arg1`        | Returns the approximate duration of arg1 in a 'human-friendly' format ("3 seconds", "2 months", "5 years") etc.                                                    |
| `uppercase arg1`             | Returns arg1 converted to uppercase.                                                                                                                               |
| `lowercase arg1`             | Returns arg1 converted to lowercase.                                                                                                                               |
| `pluralize arg1 arg2 arg3`   | If arg1 equals 1 then return arg2, otherwise return arg3.                                                                                                          |
| `slugify arg1`               | Returns the lowercase of arg1 with all non-ASCII characters and punctuation removed (expect underscores and hyphens). Whitespaces are also replaced with a hyphen. |
| `safeHTML arg1`              | Output the verbatim value of arg1 without escaping the content. This should only be used when arg1 is from a trusted source.                                       |
| `join arg1 arg2`             | Returns the values in arg1 joined using the separator arg2.                                                                                                        |
| `containsString arg1 arg2 `  | Returns true if arg1 contains the string value arg2.                                                                                                               |
| `incr arg1`                  | Increments arg1 by 1.                                                                                                                                              |
| `decr arg1`                  | Decrements arg1 by 1.                                                                                                                                              |
| `formatInt arg1`             | Returns arg1 formatted with commas as the thousands separator.                                                                                                     |
| `formatFloat arg1 arg2`      | Returns arg1 rounded to arg2 decimal places and formatted with commas as the thousands separator.                                                                  |
| `yesno arg1`                 | Returns "Yes" if arg1 is true, or "No" if arg1 is false.                                                                                                           |
| `urlSetParam arg1 arg2 arg3` | Returns the URL arg1 with the key arg2 and value arg3 added to the query string parameters.                                                                        |
| `urlDelParam arg1 arg2`      | Returns the URL arg1 with the key arg2 (and corresponding value) removed from the query string parameters.                                                         |

To add another custom template function, define the function in `internal/funcs/funcs.go` and add it to the `TemplateFuncs` map. For example:

```
var TemplateFuncs = template.FuncMap{
    ...
    "yourFunction": yourFunction,
}

func yourFunction(s string) (string, error) {
    // Do something...
}
```

## Admin tasks

The `Makefile` in the project root contains commands to easily run common admin tasks:

|                |                                                                                |
|----------------|--------------------------------------------------------------------------------|
| `$ make tidy`  | Format all code using `go fmt` and tidy the `go.mod` file.                     |
| `$ make audit` | Run `go vet`, `staticheck`, execute all tests and verify required modules.     |
| `$ make build` | Build a binary for the `cmd/api` application and store it in the `bin` folder. |
| `$ make run`   | Build and then run a binary for the `cmd/api` application.                     |

## Running background tasks

A `backgroundTask()` helper is included in the `cmd/api/helpers.go` file. You can call this in your handlers, helpers and middleware to run any logic in a separate background goroutine. This useful for things like sending emails, or completing slow-running jobs.

You can call it like so:

```
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    app.backgroundTask(func() error {
        // The logic you want to execute in a background task goes here.
        // It should return an error, or nil.
        err := doSomething()
        if err != nil {
            return err
        }

        return nil
    })

    ...
}
```

Using the `backgroundTask()` helper will automatically recover any panics in the background task logic, and when performing a graceful shutdown the application will wait for any background tasks to finish running before it exits.

## Application version

The application version number is generated automatically based on your latest version control system revision number. If you are using Git, this will be your latest Git commit hash. It can be retrieved by calling the `version.Get()` function from the `internal/version` package.

Important: The version control system revision number will only be available when the application is built using `go build`. If you run the application using `go run` then `version.Get()` will return the string `"unavailable"`.

## Changing the module path

The module path is currently set to `github.com/Authorie/authorie-backend`. If you want to change this please find and replace all instances of `github.com/Authorie/authorie-backend` in the codebase with your own module path.